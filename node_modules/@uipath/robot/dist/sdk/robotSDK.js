"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var traceEvent_1 = require("../enums/traceEvent");
var language_1 = require("../locale/language");
var models_1 = require("../models");
var implementation_1 = require("../requests/implementation");
var utils_1 = require("../utils");
var constants_1 = require("../utils/constants");
var appinsightsLogger_1 = require("../utils/logger/appinsightsLogger");
/**
 * Robot SDK class
 */
var RobotSDK = /** @class */ (function () {
    function RobotSDK() {
        var _this = this;
        /**
        * Method to attach event handlers on the SDK.
        * @param eventName Available SDK events are 'consent-prompt', 'missing-components'.
        * @param eventHanlder Event handler callback function called when event occurs.
        */
        this.on = function (eventName, eventHanlder) {
            switch (eventName) {
                case constants_1.Constants.CONSENT_PROMPT: {
                    _this.eventHandlers.on(constants_1.Constants.CONSENT_PROMPT, eventHanlder);
                    break;
                }
                case constants_1.Constants.MISSING_COMPONENTS: {
                    _this.eventHandlers.on(constants_1.Constants.MISSING_COMPONENTS, eventHanlder);
                    break;
                }
                default: {
                    _this.trace(traceEvent_1.TraceEvent.Invalid_Event, {});
                    break;
                }
            }
        };
        /**
        * Init method set custom consent code handling.
        * @returns {IRobotSDK} implemented instance
        */
        this.init = function () {
            _this.trace(traceEvent_1.TraceEvent.Init, {});
            return _this;
        };
        /**
        * Method to retrieve all published robot processes on users local machine.
        * @returns Deferred promise of type RobotProcess[] which will be resolved/rejected based on http response.
        */
        this.getProcesses = function () {
            _this.trace(traceEvent_1.TraceEvent.Get_Processes, {});
            var deferredPromise = new utils_1.Deferred();
            try {
                _this.sendRequest(new implementation_1.RobotProcessRequest(), deferredPromise);
            }
            catch (error) {
                deferredPromise.reject(error);
                _this.traceError(traceEvent_1.TraceEvent.Get_Processes, error);
            }
            return deferredPromise.promise;
        };
        /**
        * Method to invoke a robot process.
        * @param job Job object containing all information about the robot process to run.
        * @returns Deferred promise which is resolved with job result when robot process completes.
        */
        this.startJob = function (job) { return __awaiter(_this, void 0, void 0, function () {
            var deferredPromise, jobResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.trace(traceEvent_1.TraceEvent.Run_Robot, {});
                        deferredPromise = new utils_1.Deferred();
                        return [4 /*yield*/, this.startRobot(job.processId, job.argument)];
                    case 1:
                        jobResponse = _a.sent();
                        job.jobId = jobResponse.jobId;
                        this.jobStatusPoll(job, deferredPromise);
                        return [2 /*return*/, deferredPromise.promise];
                }
            });
        }); };
        /**
        * Method to stop a robot process job.
        * @param job Job object containing all information about the robot process run to cancel.
        * @returns Deferred promise which is resolved with job result when robot process is cancelled.
        */
        this.stopProcess = function (process) { return __awaiter(_this, void 0, void 0, function () {
            var deferredPromise, response, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.trace(traceEvent_1.TraceEvent.Stop_Process, {});
                        deferredPromise = new utils_1.Deferred();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, new implementation_1.StopProcessRequest(process).set(this.robotInvocationPort, this.consentCode).send()];
                    case 2:
                        response = _a.sent();
                        if (response.isSuccess) {
                            deferredPromise.resolve();
                        }
                        else {
                            throw response.isEmpty ? "426 - " + language_1.Language.GetResource().api_not_found : response.error;
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        deferredPromise.reject(error_1);
                        this.traceError(traceEvent_1.TraceEvent.Stop_Process, error_1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, deferredPromise.promise];
                }
            });
        }); };
        /**
         * Method to invoke a robot on the local user machine.
         * @param robotProcessId Robot package id to uniquely identify robots present on local user machine.
         * @param data In arguments to be passed to the robot if any.
         * @returns Deferred promise of type job which will be resolved/rejected based on http response.
         */
        this.startRobot = function (robotProcessId, data) { return __awaiter(_this, void 0, void 0, function () {
            var deferredPromise;
            return __generator(this, function (_a) {
                if (data) {
                    data = JSON.stringify(data);
                }
                deferredPromise = new utils_1.Deferred();
                try {
                    this.sendRequest(new implementation_1.InvokeRobotRequest(robotProcessId, data), deferredPromise);
                }
                catch (error) {
                    deferredPromise.reject(error);
                }
                return [2 /*return*/, deferredPromise.promise];
            });
        }); };
        /**
        * Finds port of local listener and sends request. Requests user consent if required.
        * @param request IRequest to send.
        * @param deferredPromise Promise to resolve on completion of request.
        */
        this.sendRequest = function (request, deferredPromise) { return __awaiter(_this, void 0, void 0, function () {
            var response, error_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 6, , 7]);
                        return [4 /*yield*/, this.initializePort()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, request.set(this.robotInvocationPort, this.consentCode).send()];
                    case 2:
                        response = _a.sent();
                        if (!response.isUnauthorized) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.resendAfterConsent(request)];
                    case 3:
                        response = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        if (response.isEmpty) {
                            this.showMissingComponents();
                        }
                        _a.label = 5;
                    case 5:
                        response.resolve(deferredPromise);
                        return [3 /*break*/, 7];
                    case 6:
                        error_2 = _a.sent();
                        deferredPromise.reject(error_2);
                        return [3 /*break*/, 7];
                    case 7: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Initialize method that initializes listener port running on local session.
         * @returns Promise.
         */
        this.initializePort = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.robotInvocationPort === 0)) return [3 /*break*/, 2];
                        this.consentCode = 0;
                        _a = this;
                        return [4 /*yield*/, this.getPort()];
                    case 1:
                        _a.robotInvocationPort = _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Method to find the port on which local listener is running.
         * @returns Deferred promise of type number which will be resolved/rejected based on http response.
         */
        this.getPort = function () { return __awaiter(_this, void 0, void 0, function () {
            var deferredPromise, request, response, result, error_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deferredPromise = new utils_1.Deferred();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        request = new implementation_1.PortRequest(this.settings.portNumber, this.consentCode);
                        return [4 /*yield*/, request.getPort()];
                    case 2:
                        response = _a.sent();
                        if (!(response.isUnauthorized && this.consentCode === 0)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.askForConsent()];
                    case 3:
                        result = _a.sent();
                        deferredPromise.resolve(result);
                        return [3 /*break*/, 5];
                    case 4:
                        if (response.isEmpty) {
                            this.showMissingComponents();
                            deferredPromise.reject(new Error('500 - Robot Service down'));
                        }
                        else {
                            response.resolve(deferredPromise);
                        }
                        _a.label = 5;
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        error_3 = _a.sent();
                        this.traceError(traceEvent_1.TraceEvent.Get_Port, error_3);
                        deferredPromise.reject(error_3);
                        return [3 /*break*/, 7];
                    case 7: return [2 /*return*/, deferredPromise.promise];
                }
            });
        }); };
        /**
        * Generates a random number which will be passed to protocol handler and shown to user to approve as consent.
        * Polls for 60 seconds to determine if user has consented.
        */
        this.askForConsent = function () {
            var deferredPromise = new utils_1.Deferred();
            _this.consentCode = utils_1.RandomUtil.getRandomNumber();
            utils_1.ProtocolUtil.openUiPathProtocol(_this.consentCode);
            _this.showConsentCode(_this.consentCode);
            _this.pollForApprovedConsent(_this.getPort)
                .then(function (response) {
                utils_1.HtmlUtil.hideConsentOverlay();
                deferredPromise.resolve(response);
            })
                .catch(function (error) {
                utils_1.HtmlUtil.hideConsentOverlay();
                deferredPromise.reject(error);
                _this.traceError(traceEvent_1.TraceEvent.Consent_Timeout, error);
            });
            _this.trace(traceEvent_1.TraceEvent.User_Consent_Raised, {});
            return deferredPromise.promise;
        };
        /**
        * Polls the given function for 1 min until success.
        * @param fn Function to poll.
        */
        this.pollForApprovedConsent = function (fn) { return utils_1.PollUtil.poll(fn, constants_1.Constants.POLL_TIMEOUT, constants_1.Constants.POLL_TIMEINTERVAL); };
        /**
        * Makes request after user consents access.
        * @param request IRequest to send.
        */
        this.resendAfterConsent = function (request) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.askForConsent()];
                    case 1:
                        _a.robotInvocationPort = _b.sent();
                        return [2 /*return*/, request.set(this.robotInvocationPort, this.consentCode).send()];
                }
            });
        }); };
        /**
        * Polls recursively until completion of currently running robot process job.
        * @param job Job that is currently running.
        * @param statusChangeCallback callback method to call if job status has changed
        * @param deferredPromise Promise to resolve/reject once job completes.
        */
        this.jobStatusPoll = function (job, deferredPromise) { return __awaiter(_this, void 0, void 0, function () {
            var jobResponse, error_4;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getJobStatus(job)];
                    case 1:
                        jobResponse = _a.sent();
                        jobResponse.status.forEach(function (value) { return job.dispatch(value); });
                        if (jobResponse.isExecuting) {
                            setTimeout(function () { return _this.jobStatusPoll(job, deferredPromise); }, this.settings.pollTimeInterval);
                        }
                        else if (jobResponse.isClosed) {
                            deferredPromise.resolve(jobResponse.output.Arguments);
                        }
                        else {
                            deferredPromise.reject(jobResponse.errorResponse);
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        error_4 = _a.sent();
                        deferredPromise.reject(error_4);
                        this.traceError(traceEvent_1.TraceEvent.Job_Status_Poll, error_4);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); };
        /**
        * Method to get job status of any running/completed job.
        * @param job Job object for which status needs to be found.
        * @returns Deferred promise of type JobResult which will be resolved/rejected based on http response.
        */
        this.getJobStatus = function (job) { return __awaiter(_this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new implementation_1.JobStatusRequest(job).set(this.robotInvocationPort, this.consentCode).send()];
                    case 1:
                        response = _a.sent();
                        if (response.isSuccess && response.data) {
                            return [2 /*return*/, response.data];
                        }
                        else {
                            throw new Error("500 - " + language_1.Language.GetResource().job_status_error);
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        /**
         * Calls consent-prompt event handler or shows SDK consent overlay
         * @param consentCode Randomly generated consent code
         */
        this.showConsentCode = function (consentCode) {
            if (_this.eventHandlers.has(constants_1.Constants.CONSENT_PROMPT)) {
                _this.eventHandlers.dispatch(constants_1.Constants.CONSENT_PROMPT, consentCode);
            }
            else {
                utils_1.HtmlUtil.showConsentOverlay(consentCode, _this.settings.portNumber);
            }
        };
        /**
         * Calls 'missing-components' event handler or shows SDK error overlay
         */
        this.showMissingComponents = function () {
            if (_this.eventHandlers.has(constants_1.Constants.MISSING_COMPONENTS)) {
                _this.eventHandlers.dispatch(constants_1.Constants.MISSING_COMPONENTS);
            }
            else {
                utils_1.HtmlUtil.showErrorOverlay();
            }
            _this.trace(traceEvent_1.TraceEvent.Missing_Components, {});
        };
        this.trace = function (event, properties) {
            if (!_this.settings.disableTelemetry) {
                _this.logger.trace(event, properties, _this.settings.appOrigin);
            }
        };
        this.traceError = function (event, properties) {
            if (!_this.settings.disableTelemetry) {
                _this.logger.traceError(event, properties, _this.settings.appOrigin);
            }
        };
        this.robotInvocationPort = 0;
        this.consentCode = 0;
        this.settings = new models_1.Settings(constants_1.Constants.DEFAULT_PORT, constants_1.Constants.POLL_TIMEINTERVAL, false);
        this.eventHandlers = new utils_1.Dispatcher();
        this.logger = new appinsightsLogger_1.AppInsightsLogger();
    }
    return RobotSDK;
}());
var robotSDK = new RobotSDK();
/**
 * Class to restrict exposing other private methods in RobotSDK object.
 */
var SDK = /** @class */ (function () {
    function SDK() {
        var _this = this;
        /**
         * Init method set custom consent code handling.
         * @returns {IRobotSDK} instance
         */
        this.init = function () { return _this; };
        /**
         * Method to retrieve all published robot processes on users local machine.
         * @returns Deferred promise of type RobotProcess[] which will be resolved/rejected based on http response.
         */
        this.getProcesses = function () { return robotSDK.getProcesses(); };
        /**
         * Method to attach event handlers on the SDK.
         * @param eventName Available SDK events are 'consent-prompt', 'missing-components'.
         * @param eventHanlder Event handler callback function called when event occurs.
         */
        this.on = function (eventName, eventHanlder) { return robotSDK.on(eventName, eventHanlder); };
        /**
         * Method to invoke a robot process.
         * @param job Job object containing all information about the robot process to run.
         * @returns Deferred promise which is resolved with job result when robot process completes.
         */
        this.startJob = function (job) { return robotSDK.startJob(job); };
        /**
       * Method to stop an executing/running robot process.
       * @param process RobotProcess object containing all information about the robot process to stop.
       * @returns Deferred promise which is resolved with job result when robot process is cancelled.
       */
        this.stopProcess = function (process) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/, robotSDK.stopProcess(process)];
        }); }); };
    }
    Object.defineProperty(SDK.prototype, "settings", {
        /**
         * SDK settings
         */
        get: function () {
            return robotSDK.settings;
        },
        enumerable: true,
        configurable: true
    });
    return SDK;
}());
exports.SDK = SDK;
