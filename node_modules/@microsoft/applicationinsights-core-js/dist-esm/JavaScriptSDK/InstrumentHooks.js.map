{"version":3,"file":"InstrumentHooks.js","sourceRoot":"","sources":["../../src/JavaScriptSDK/InstrumentHooks.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { \r\n    IInstrumentHooksCallbacks, IInstrumentHooks, IInstrumentHook, IInstrumentCallDetails, InstrumentorHooksCallback \r\n} from \"../JavaScriptSDK.Interfaces/IInstrumentHooks\";\r\nimport {\r\n    strFunction, strPrototype\r\n} from \"./EnvUtils\"\r\nimport { CoreUtils } from './CoreUtils';\r\n\r\nconst aiInstrumentHooks = \"_aiHooks\";\r\n\r\nconst enum CallbackType {\r\n    Request = 0,\r\n    Response = 1,\r\n    HookError = 2,\r\n    FunctionError = 3\r\n};\r\n\r\nconst cbNames = [\r\n    \"req\", \"rsp\", \"hkErr\", \"fnErr\"\r\n];\r\n\r\n/** @ignore */\r\nfunction _arrLoop<T>(arr:T[], fn:(value:T, idx:number) => boolean|number|void) {\r\n    if (arr) {\r\n        for (let lp = 0; lp < arr.length; lp++) {\r\n            if (fn(arr[lp], lp)) {\r\n                break;\r\n            }\r\n        }    \r\n    }\r\n}\r\n\r\n/** @ignore */\r\nfunction _doCallbacks(hooks:IInstrumentHook[], callDetails: IInstrumentCallDetails, cbArgs:any[], hookCtx:any[], type:CallbackType): void {\r\n    if (type >= CallbackType.Request && type <= CallbackType.HookError) {\r\n        _arrLoop(hooks, (hook, idx) => {\r\n            let cbks = hook.cbks;\r\n            let cb:InstrumentorHooksCallback = cbks[cbNames[type]];\r\n            if (cb) {\r\n        \r\n                // Set the specific hook context implementation using a lazy creation pattern\r\n                callDetails.ctx = () => {\r\n                    let ctx = hookCtx[idx] = (hookCtx[idx] || {});\r\n                    return ctx;\r\n                };\r\n\r\n                try {\r\n                    cb.apply(callDetails.inst, cbArgs);\r\n                } catch (err) {\r\n                    let orgEx = callDetails.err;\r\n                    try {\r\n                        // Report Hook error via the callback\r\n                        let hookErrorCb:InstrumentorHooksCallback = cbks[cbNames[CallbackType.HookError]];\r\n                        if (hookErrorCb) {\r\n                            callDetails.err = err;\r\n                            hookErrorCb.apply(callDetails.inst, cbArgs);\r\n                        }\r\n                    } catch(e) {\r\n                        // Not much we can do here -- swallowing the exception to avoid crashing the hosting app\r\n                    } finally {\r\n                        // restore the original exception (if any)\r\n                        callDetails.err = orgEx;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nfunction _createFunctionHook(aiHook:IInstrumentHooks) {\r\n    \r\n    // Define a temporary method that queues-up a the real method call\r\n    return function () {\r\n        let funcThis = this;\r\n        // Capture the original arguments passed to the method\r\n        let orgArgs = arguments as any;\r\n        let hooks = aiHook.h;\r\n\r\n        let funcArgs:IInstrumentCallDetails = {\r\n            name: aiHook.n,\r\n            inst: funcThis,\r\n            ctx: null,\r\n            set: _replaceArg\r\n        };\r\n\r\n        let hookCtx: any[] = [];\r\n        let cbArgs = _createArgs([funcArgs], orgArgs);\r\n\r\n        function _createArgs(target:any[], theArgs:any[]): any[] {\r\n            _arrLoop((theArgs as any), (arg) => {\r\n                target.push(arg);\r\n            });\r\n\r\n            return target;\r\n        }\r\n\r\n        function _replaceArg(idx:number, value:any) {\r\n            orgArgs = _createArgs([], orgArgs);\r\n            orgArgs[idx] = value;\r\n            cbArgs = _createArgs([funcArgs], orgArgs);\r\n        }\r\n\r\n        // Call the pre-request hooks\r\n        _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, CallbackType.Request);\r\n\r\n        // Call the original function was called\r\n        let theFunc = aiHook.f;\r\n        try {\r\n            funcArgs.rslt = theFunc.apply(funcThis, orgArgs);\r\n        } catch (err) {\r\n            // Report the request callback\r\n            funcArgs.err = err;\r\n            _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, CallbackType.FunctionError);\r\n\r\n            // rethrow the original exception so anyone listening for it can catch the exception\r\n            throw err;\r\n        }\r\n\r\n        // Call the post-request hooks\r\n        _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, CallbackType.Response);\r\n\r\n        return funcArgs.rslt;\r\n    };\r\n}\r\n\r\n/** @ignore */\r\nfunction _getOwner(target:any, name:string, checkPrototype:boolean): any {\r\n    let owner = null;\r\n    if (target) {\r\n        if (CoreUtils.hasOwnProperty(target, name)) {\r\n            owner = target;\r\n        } else if (checkPrototype) {\r\n            owner = _getOwner(target[strPrototype], name, false);\r\n        }\r\n    }\r\n\r\n    return owner;\r\n}\r\n\r\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcName - The function name\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n */\r\nexport function InstrumentProto(target:any, funcName:string, callbacks: IInstrumentHooksCallbacks): IInstrumentHook {\r\n    if (target) {\r\n        return InstrumentFunc(target[strPrototype], funcName, callbacks, false);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcNames - The function names to intercept and call\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n */\r\nexport function InstrumentProtos(target:any, funcNames:string[], callbacks: IInstrumentHooksCallbacks): IInstrumentHook[] {\r\n    if (target) {\r\n        return InstrumentFuncs(target[strPrototype], funcNames, callbacks, false);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcName - The function name\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function\r\n */\r\nexport function InstrumentFunc(target:any, funcName:string, callbacks: IInstrumentHooksCallbacks, checkPrototype:boolean = true): IInstrumentHook {\r\n    if (target && funcName && callbacks) {\r\n        let owner = _getOwner(target, funcName, checkPrototype);\r\n        let fn = owner[funcName]\r\n        if (typeof fn === strFunction) {\r\n            let aiHook:IInstrumentHooks = fn[aiInstrumentHooks];\r\n            if (!aiHook) {\r\n                // Only hook the function once\r\n                aiHook = {\r\n                    i: 0,\r\n                    n: funcName,\r\n                    f: fn,\r\n                    h: []\r\n                };\r\n\r\n                // Override (hook) the original function\r\n                let newFunc = _createFunctionHook(aiHook);\r\n                newFunc[aiInstrumentHooks] = aiHook;        // Tag and store the function hooks\r\n                owner[funcName] = newFunc;\r\n            }\r\n\r\n            const theHook: IInstrumentHook = {\r\n                // tslint:disable:object-literal-shorthand\r\n                id: aiHook.i,\r\n                cbks: callbacks,\r\n                rm: function() {\r\n                    // DO NOT Use () => { shorthand for the function as the this gets replaced\r\n                    // with the outer this and not the this for theHook instance.\r\n                    let id = this.id;\r\n                    _arrLoop(aiHook.h, (hook, idx) => {\r\n                        if (hook.id === id) {\r\n                            aiHook.h.splice(idx, 1);\r\n                            return 1;\r\n                        }\r\n                    });\r\n                }\r\n                // tslint:enable:object-literal-shorthand\r\n            }\r\n\r\n            aiHook.i ++;\r\n            aiHook.h.push(theHook);\r\n\r\n            return theHook;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Intercept the named functions for the target class / object\r\n * @param target - The target object\r\n * @param funcNames - The function names to intercept and call\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function\r\n */\r\nexport function InstrumentFuncs(target:any, funcNames:string[], callbacks: IInstrumentHooksCallbacks, checkPrototype:boolean = true): IInstrumentHook[] {\r\n    let hooks: IInstrumentHook[] = null;\r\n    _arrLoop(funcNames, (funcName) => {\r\n        let hook = InstrumentFunc(target, funcName, callbacks, checkPrototype);\r\n        if (hook) {\r\n            if (!hooks) {\r\n                hooks = [];\r\n            }\r\n\r\n            hooks.push(hook);\r\n        }\r\n    });\r\n\r\n    return hooks;\r\n}\r\n"]}