// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
"use strict";
import { CoreUtils } from "./CoreUtils";
import { ChannelController } from './ChannelController';
import { ProcessTelemetryContext } from './ProcessTelemetryContext';
import { initializePlugins, sortPlugins } from './TelemetryHelpers';
var validationError = "Extensions must provide callback to initialize";
var _arrForEach = CoreUtils.arrForEach;
var _isNullOrUndefined = CoreUtils.isNullOrUndefined;
var BaseCore = /** @class */ (function () {
    function BaseCore() {
        var _isInitialized = false;
        var _this = this;
        _this._extensions = new Array();
        _this._channelController = new ChannelController();
        _this.isInitialized = function () { return _isInitialized; };
        _this._setInit = function (value) { _isInitialized = value; };
        _this._eventQueue = [];
    }
    BaseCore.prototype.initialize = function (config, extensions, logger, notificationManager) {
        var _this = this;
        // Make sure core is only initialized once
        if (_this.isInitialized()) {
            throw Error("Core should not be initialized more than once");
        }
        if (!config || _isNullOrUndefined(config.instrumentationKey)) {
            throw Error("Please provide instrumentation key");
        }
        _this.config = config;
        var channelController = _this._channelController;
        if (!notificationManager) {
            // Create Dummy notification manager
            notificationManager = CoreUtils.objCreate({
                addNotificationListener: function (listener) { },
                removeNotificationListener: function (listener) { },
                eventsSent: function (events) { },
                eventsDiscarded: function (events, reason) { },
                eventsSendRequest: function (sendReason, isAsync) { }
            });
        }
        _this._notificationManager = notificationManager;
        config.extensions = _isNullOrUndefined(config.extensions) ? [] : config.extensions;
        // add notification to the extensions in the config so other plugins can access it
        var extConfig = config.extensionConfig = _isNullOrUndefined(config.extensionConfig) ? {} : config.extensionConfig;
        extConfig.NotificationManager = notificationManager;
        if (!logger) {
            logger = CoreUtils.objCreate({
                throwInternal: function (severity, msgId, msg, properties, isUserAct) {
                    if (isUserAct === void 0) { isUserAct = false; }
                },
                warnToConsole: function (message) { },
                resetInternalMessageCount: function () { }
            });
        }
        _this.logger = logger;
        // Concat all available extensions
        var allExtensions = [];
        allExtensions.push.apply(allExtensions, extensions.concat(config.extensions));
        allExtensions = sortPlugins(allExtensions);
        var coreExtensions = [];
        var channelExtensions = [];
        // Check if any two extensions have the same priority, then warn to console
        // And extract the local extensions from the 
        var extPriorities = {};
        // Extension validation
        _arrForEach(allExtensions, function (ext) {
            if (_isNullOrUndefined(ext) || _isNullOrUndefined(ext.initialize)) {
                throw Error(validationError);
            }
            var extPriority = ext.priority;
            var identifier = ext.identifier;
            if (ext && extPriority) {
                if (!_isNullOrUndefined(extPriorities[extPriority])) {
                    logger.warnToConsole("Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
                }
                else {
                    // set a value
                    extPriorities[extPriority] = identifier;
                }
            }
            // Split extensions to core and channelController
            if (!extPriority || extPriority < channelController.priority) {
                // Add to core extension that will be managed by BaseCore
                coreExtensions.push(ext);
            }
            else {
                // Add all other extensions to be managed by the channel controller
                channelExtensions.push(ext);
            }
        });
        // Validation complete
        // Add the channelController to the complete extension collection and
        // to the end of the core extensions
        allExtensions.push(channelController);
        coreExtensions.push(channelController);
        // Sort the complete set of extensions by priority
        allExtensions = sortPlugins(allExtensions);
        _this._extensions = allExtensions;
        // initialize channel controller first, this will initialize all channel plugins
        initializePlugins(new ProcessTelemetryContext([channelController], config, _this), allExtensions);
        initializePlugins(new ProcessTelemetryContext(coreExtensions, config, _this), allExtensions);
        // Now reset the extensions to just those being managed by Basecore
        _this._extensions = coreExtensions;
        if (_this.getTransmissionControls().length === 0) {
            throw new Error("No channels available");
        }
        _this._setInit(true);
    };
    BaseCore.prototype.getTransmissionControls = function () {
        return this._channelController.getChannelControls();
    };
    BaseCore.prototype.track = function (telemetryItem) {
        var _this = this;
        if (!telemetryItem.iKey) {
            // setup default iKey if not passed in
            telemetryItem.iKey = _this.config.instrumentationKey;
        }
        if (!telemetryItem.time) {
            // add default timestamp if not passed in
            telemetryItem.time = CoreUtils.toISOString(new Date());
        }
        if (_isNullOrUndefined(telemetryItem.ver)) {
            // CommonSchema 4.0
            telemetryItem.ver = "4.0";
        }
        if (_this.isInitialized()) {
            // Release queue
            if (_this._eventQueue.length > 0) {
                _arrForEach(_this._eventQueue, function (event) {
                    _this.getProcessTelContext().processNext(event);
                });
                _this._eventQueue = [];
            }
            // Process the telemetry plugin chain
            _this.getProcessTelContext().processNext(telemetryItem);
        }
        else {
            // Queue events until all extensions are initialized
            _this._eventQueue.push(telemetryItem);
        }
    };
    BaseCore.prototype.getProcessTelContext = function () {
        var _this = this;
        var extensions = _this._extensions;
        var thePlugins = extensions;
        // invoke any common telemetry processors before sending through pipeline
        if (!extensions || extensions.length === 0) {
            // Pass to Channel controller so data is sent to correct channel queues
            thePlugins = [_this._channelController];
        }
        return new ProcessTelemetryContext(thePlugins, _this.config, _this);
    };
    return BaseCore;
}());
export { BaseCore };
//# sourceMappingURL=BaseCore.js.map