// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
"use strict";
import { CoreUtils } from "./CoreUtils";
import { BaseTelemetryPlugin } from './BaseTelemetryPlugin';
import { ProcessTelemetryContext } from './ProcessTelemetryContext';
import { initializePlugins } from './TelemetryHelpers';
var ChannelControllerPriority = 500;
var ChannelValidationMessage = "Channel has invalid priority";
var _arrForEach = CoreUtils.arrForEach;
var _objDefineAccessors = CoreUtils.objDefineAccessors;
function _checkQueuePriority(queue) {
    _arrForEach(queue, function (queueItem) {
        if (queueItem.priority < ChannelControllerPriority) {
            throw Error(ChannelValidationMessage + queueItem.identifier);
        }
    });
}
function _addChannelQueue(channelQueues, queue) {
    if (queue && queue.length > 0) {
        queue = queue.sort(function (a, b) {
            return a.priority - b.priority;
        });
        _checkQueuePriority(queue);
        channelQueues.push(queue);
    }
}
function _createChannelQueues(channels, extensions) {
    var channelQueues = [];
    if (channels) {
        // Add and sort the configuration channel queues
        _arrForEach(channels, function (queue) { return _addChannelQueue(channelQueues, queue); });
    }
    if (extensions) {
        // Create a new channel queue for any extensions with a priority > the ChannelControllerPriority
        var extensionQueue_1 = [];
        _arrForEach(extensions, function (plugin) {
            if (plugin.priority > ChannelControllerPriority) {
                extensionQueue_1.push(plugin);
            }
        });
        _addChannelQueue(channelQueues, extensionQueue_1);
    }
    return channelQueues;
}
var ChannelController = /** @class */ (function (_super) {
    __extends(ChannelController, _super);
    function ChannelController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.identifier = "ChannelControllerPlugin";
        _this.priority = ChannelControllerPriority; // in reserved range 100 to 200
        return _this;
    }
    ChannelController.prototype.processTelemetry = function (item, itemCtx) {
        var _this = this;
        if (this._channelQueue) {
            _arrForEach(this._channelQueue, function (queues) {
                // pass on to first item in queue
                if (queues.length > 0) {
                    // Copying the item context as we could have mutiple chains that are executing asynchronously
                    // and calling _getDefTelCtx as it's possible that the caller doesn't pass any context
                    var chainCtx = _this._getTelCtx(itemCtx).createNew(queues);
                    chainCtx.processNext(item);
                }
            });
        }
    };
    ;
    ChannelController.prototype.getChannelControls = function () {
        return this._channelQueue;
    };
    ChannelController.prototype.initialize = function (config, core, extensions) {
        var _self = this;
        if (_self.isInitialized()) {
            // already initialized
            return;
        }
        _super.prototype.initialize.call(this, config, core, extensions);
        if (config.isCookieUseDisabled) {
            CoreUtils.disableCookies();
        }
        var channelQueue = _self._channelQueue = _createChannelQueues((config || {}).channels, extensions);
        // Initialize the Queues
        _arrForEach(channelQueue, function (queue) { return initializePlugins(new ProcessTelemetryContext(queue, config, core), extensions); });
    };
    /**
     * Static constructor, attempt to create accessors
     */
    // tslint:disable-next-line
    ChannelController._staticInit = (function () {
        // Dynamically create get/set property accessors
        _objDefineAccessors(ChannelController.prototype, "ChannelControls", ChannelController.prototype.getChannelControls);
        _objDefineAccessors(ChannelController.prototype, "channelQueue", ChannelController.prototype.getChannelControls);
    })();
    return ChannelController;
}(BaseTelemetryPlugin));
export { ChannelController };
//# sourceMappingURL=ChannelController.js.map